{"format": "torch", "nodes": [{"name": "encode", "id": 139699351393312, "class_name": "SVSEncoder_ver2(\n  (blocks): Sequential(\n    (0): Sequential(\n      (0): Conv3d(1, 4, kernel_size=(7, 7, 7), stride=(2, 2, 2), padding=(3, 3, 3))\n      (1): SEResNetBlock(\n        (conv1): Conv3d(4, 4, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n        (bn1): BatchNorm3d(4, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (conv2): Conv3d(4, 4, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n        (bn2): BatchNorm3d(4, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (se): SEBlock(\n          (pool): AdaptiveAvgPool3d(output_size=1)\n          (fc): Sequential(\n            (0): Linear(in_features=4, out_features=0, bias=True)\n            (1): LeakyReLU(negative_slope=0.01, inplace=True)\n            (2): Linear(in_features=0, out_features=4, bias=True)\n            (3): Sigmoid()\n          )\n        )\n        (relu): LeakyReLU(negative_slope=0.01, inplace=True)\n        (shortcut): Sequential()\n      )\n      (2): BatchNorm3d(4, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (3): LeakyReLU(negative_slope=0.01)\n    )\n    (1): Sequential(\n      (0): Conv3d(4, 8, kernel_size=(4, 4, 4), stride=(2, 2, 2), padding=(1, 1, 1))\n      (1): SEResNetBlock(\n        (conv1): Conv3d(8, 8, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n        (bn1): BatchNorm3d(8, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (conv2): Conv3d(8, 8, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n        (bn2): BatchNorm3d(8, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (se): SEBlock(\n          (pool): AdaptiveAvgPool3d(output_size=1)\n          (fc): Sequential(\n            (0): Linear(in_features=8, out_features=0, bias=True)\n            (1): LeakyReLU(negative_slope=0.01, inplace=True)\n            (2): Linear(in_features=0, out_features=8, bias=True)\n            (3): Sigmoid()\n          )\n        )\n        (relu): LeakyReLU(negative_slope=0.01, inplace=True)\n        (shortcut): Sequential()\n      )\n      (2): BatchNorm3d(8, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (3): LeakyReLU(negative_slope=0.01)\n    )\n    (2): Sequential(\n      (0): Conv3d(8, 16, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n      (1): SEResNetBlock(\n        (conv1): Conv3d(16, 16, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n        (bn1): BatchNorm3d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (conv2): Conv3d(16, 16, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n        (bn2): BatchNorm3d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (se): SEBlock(\n          (pool): AdaptiveAvgPool3d(output_size=1)\n          (fc): Sequential(\n            (0): Linear(in_features=16, out_features=1, bias=True)\n            (1): LeakyReLU(negative_slope=0.01, inplace=True)\n            (2): Linear(in_features=1, out_features=16, bias=True)\n            (3): Sigmoid()\n          )\n        )\n        (relu): LeakyReLU(negative_slope=0.01, inplace=True)\n        (shortcut): Sequential()\n      )\n      (2): BatchNorm3d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (3): LeakyReLU(negative_slope=0.01)\n    )\n    (3): Sequential(\n      (0): Conv3d(16, 1, kernel_size=(1, 1, 1), stride=(1, 1, 1))\n      (1): BatchNorm3d(1, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): LeakyReLU(negative_slope=0.01)\n    )\n  )\n)", "parameters": [["blocks.0.0.weight", [4, 1, 7, 7, 7]], ["blocks.0.0.bias", [4]], ["blocks.0.1.conv1.weight", [4, 4, 3, 3, 3]], ["blocks.0.1.conv1.bias", [4]], ["blocks.0.1.bn1.weight", [4]], ["blocks.0.1.bn1.bias", [4]], ["blocks.0.1.conv2.weight", [4, 4, 3, 3, 3]], ["blocks.0.1.conv2.bias", [4]], ["blocks.0.1.bn2.weight", [4]], ["blocks.0.1.bn2.bias", [4]], ["blocks.0.1.se.fc.0.weight", [0, 4]], ["blocks.0.1.se.fc.0.bias", [0]], ["blocks.0.1.se.fc.2.weight", [4, 0]], ["blocks.0.1.se.fc.2.bias", [4]], ["blocks.0.2.weight", [4]], ["blocks.0.2.bias", [4]], ["blocks.1.0.weight", [8, 4, 4, 4, 4]], ["blocks.1.0.bias", [8]], ["blocks.1.1.conv1.weight", [8, 8, 3, 3, 3]], ["blocks.1.1.conv1.bias", [8]], ["blocks.1.1.bn1.weight", [8]], ["blocks.1.1.bn1.bias", [8]], ["blocks.1.1.conv2.weight", [8, 8, 3, 3, 3]], ["blocks.1.1.conv2.bias", [8]], ["blocks.1.1.bn2.weight", [8]], ["blocks.1.1.bn2.bias", [8]], ["blocks.1.1.se.fc.0.weight", [0, 8]], ["blocks.1.1.se.fc.0.bias", [0]], ["blocks.1.1.se.fc.2.weight", [8, 0]], ["blocks.1.1.se.fc.2.bias", [8]], ["blocks.1.2.weight", [8]], ["blocks.1.2.bias", [8]], ["blocks.2.0.weight", [16, 8, 3, 3, 3]], ["blocks.2.0.bias", [16]], ["blocks.2.1.conv1.weight", [16, 16, 3, 3, 3]], ["blocks.2.1.conv1.bias", [16]], ["blocks.2.1.bn1.weight", [16]], ["blocks.2.1.bn1.bias", [16]], ["blocks.2.1.conv2.weight", [16, 16, 3, 3, 3]], ["blocks.2.1.conv2.bias", [16]], ["blocks.2.1.bn2.weight", [16]], ["blocks.2.1.bn2.bias", [16]], ["blocks.2.1.se.fc.0.weight", [1, 16]], ["blocks.2.1.se.fc.0.bias", [1]], ["blocks.2.1.se.fc.2.weight", [16, 1]], ["blocks.2.1.se.fc.2.bias", [16]], ["blocks.2.2.weight", [16]], ["blocks.2.2.bias", [16]], ["blocks.3.0.weight", [1, 16, 1, 1, 1]], ["blocks.3.0.bias", [1]], ["blocks.3.1.weight", [1]], ["blocks.3.1.bias", [1]]], "output_shape": [[8, 1, 64, 64, 64]], "num_parameters": [1372, 4, 432, 4, 4, 4, 432, 4, 4, 4, 0, 0, 0, 4, 4, 4, 2048, 8, 1728, 8, 8, 8, 1728, 8, 8, 8, 0, 0, 0, 8, 8, 8, 3456, 16, 6912, 16, 16, 16, 6912, 16, 16, 16, 16, 1, 16, 16, 16, 16, 16, 1, 1, 1]}, {"name": "vq", "id": 139699339947952, "class_name": "VectorQuantizer(\n  (embedding): Embedding(512, 1)\n)", "parameters": [["embedding.weight", [512, 1]]], "output_shape": [[], [8, 1, 64, 64, 64], [2097152, 512]], "num_parameters": [512]}, {"name": "decode", "id": 139699339943296, "class_name": "SVSDecoder_ver2(\n  (blocks): Sequential(\n    (0): Sequential(\n      (0): ConvTranspose3d(1, 32, kernel_size=(1, 1, 1), stride=(1, 1, 1))\n      (1): DecoderSEResNetBlock(\n        (conv1): ConvTranspose3d(32, 32, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n        (bn1): BatchNorm3d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (conv2): ConvTranspose3d(32, 32, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n        (bn2): BatchNorm3d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (se): SEBlock(\n          (pool): AdaptiveAvgPool3d(output_size=1)\n          (fc): Sequential(\n            (0): Linear(in_features=32, out_features=2, bias=True)\n            (1): LeakyReLU(negative_slope=0.01, inplace=True)\n            (2): Linear(in_features=2, out_features=32, bias=True)\n            (3): Sigmoid()\n          )\n        )\n        (relu): LeakyReLU(negative_slope=0.01, inplace=True)\n        (shortcut): Sequential()\n      )\n      (2): BatchNorm3d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (3): LeakyReLU(negative_slope=0.01)\n    )\n    (1): Sequential(\n      (0): ConvTranspose3d(32, 16, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n      (1): DecoderSEResNetBlock(\n        (conv1): ConvTranspose3d(16, 16, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n        (bn1): BatchNorm3d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (conv2): ConvTranspose3d(16, 16, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n        (bn2): BatchNorm3d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (se): SEBlock(\n          (pool): AdaptiveAvgPool3d(output_size=1)\n          (fc): Sequential(\n            (0): Linear(in_features=16, out_features=1, bias=True)\n            (1): LeakyReLU(negative_slope=0.01, inplace=True)\n            (2): Linear(in_features=1, out_features=16, bias=True)\n            (3): Sigmoid()\n          )\n        )\n        (relu): LeakyReLU(negative_slope=0.01, inplace=True)\n        (shortcut): Sequential()\n      )\n      (2): BatchNorm3d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (3): LeakyReLU(negative_slope=0.01)\n    )\n    (2): Sequential(\n      (0): ConvTranspose3d(16, 8, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n      (1): DecoderSEResNetBlock(\n        (conv1): ConvTranspose3d(8, 8, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n        (bn1): BatchNorm3d(8, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (conv2): ConvTranspose3d(8, 8, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n        (bn2): BatchNorm3d(8, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (se): SEBlock(\n          (pool): AdaptiveAvgPool3d(output_size=1)\n          (fc): Sequential(\n            (0): Linear(in_features=8, out_features=0, bias=True)\n            (1): LeakyReLU(negative_slope=0.01, inplace=True)\n            (2): Linear(in_features=0, out_features=8, bias=True)\n            (3): Sigmoid()\n          )\n        )\n        (relu): LeakyReLU(negative_slope=0.01, inplace=True)\n        (shortcut): Sequential()\n      )\n      (2): BatchNorm3d(8, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (3): LeakyReLU(negative_slope=0.01)\n    )\n    (3): Sequential(\n      (0): ConvTranspose3d(8, 4, kernel_size=(4, 4, 4), stride=(2, 2, 2), padding=(1, 1, 1))\n      (1): DecoderSEResNetBlock(\n        (conv1): ConvTranspose3d(4, 4, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n        (bn1): BatchNorm3d(4, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (conv2): ConvTranspose3d(4, 4, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n        (bn2): BatchNorm3d(4, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (se): SEBlock(\n          (pool): AdaptiveAvgPool3d(output_size=1)\n          (fc): Sequential(\n            (0): Linear(in_features=4, out_features=0, bias=True)\n            (1): LeakyReLU(negative_slope=0.01, inplace=True)\n            (2): Linear(in_features=0, out_features=4, bias=True)\n            (3): Sigmoid()\n          )\n        )\n        (relu): LeakyReLU(negative_slope=0.01, inplace=True)\n        (shortcut): Sequential()\n      )\n      (2): BatchNorm3d(4, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (3): LeakyReLU(negative_slope=0.01)\n    )\n    (4): Sequential(\n      (0): ConvTranspose3d(4, 1, kernel_size=(4, 4, 4), stride=(2, 2, 2), padding=(1, 1, 1))\n      (1): DecoderSEResNetBlock(\n        (conv1): ConvTranspose3d(1, 1, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n        (bn1): BatchNorm3d(1, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (conv2): ConvTranspose3d(1, 1, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n        (bn2): BatchNorm3d(1, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n        (se): SEBlock(\n          (pool): AdaptiveAvgPool3d(output_size=1)\n          (fc): Sequential(\n            (0): Linear(in_features=1, out_features=0, bias=True)\n            (1): LeakyReLU(negative_slope=0.01, inplace=True)\n            (2): Linear(in_features=0, out_features=1, bias=True)\n            (3): Sigmoid()\n          )\n        )\n        (relu): LeakyReLU(negative_slope=0.01, inplace=True)\n        (shortcut): Sequential()\n      )\n      (2): BatchNorm3d(1, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (3): LeakyReLU(negative_slope=0.01)\n    )\n    (5): Sequential(\n      (0): ConvTranspose3d(1, 1, kernel_size=(3, 3, 3), stride=(1, 1, 1), padding=(1, 1, 1))\n      (1): BatchNorm3d(1, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n      (2): Tanh()\n    )\n  )\n)", "parameters": [["blocks.0.0.weight", [1, 32, 1, 1, 1]], ["blocks.0.0.bias", [32]], ["blocks.0.1.conv1.weight", [32, 32, 3, 3, 3]], ["blocks.0.1.conv1.bias", [32]], ["blocks.0.1.bn1.weight", [32]], ["blocks.0.1.bn1.bias", [32]], ["blocks.0.1.conv2.weight", [32, 32, 3, 3, 3]], ["blocks.0.1.conv2.bias", [32]], ["blocks.0.1.bn2.weight", [32]], ["blocks.0.1.bn2.bias", [32]], ["blocks.0.1.se.fc.0.weight", [2, 32]], ["blocks.0.1.se.fc.0.bias", [2]], ["blocks.0.1.se.fc.2.weight", [32, 2]], ["blocks.0.1.se.fc.2.bias", [32]], ["blocks.0.2.weight", [32]], ["blocks.0.2.bias", [32]], ["blocks.1.0.weight", [32, 16, 3, 3, 3]], ["blocks.1.0.bias", [16]], ["blocks.1.1.conv1.weight", [16, 16, 3, 3, 3]], ["blocks.1.1.conv1.bias", [16]], ["blocks.1.1.bn1.weight", [16]], ["blocks.1.1.bn1.bias", [16]], ["blocks.1.1.conv2.weight", [16, 16, 3, 3, 3]], ["blocks.1.1.conv2.bias", [16]], ["blocks.1.1.bn2.weight", [16]], ["blocks.1.1.bn2.bias", [16]], ["blocks.1.1.se.fc.0.weight", [1, 16]], ["blocks.1.1.se.fc.0.bias", [1]], ["blocks.1.1.se.fc.2.weight", [16, 1]], ["blocks.1.1.se.fc.2.bias", [16]], ["blocks.1.2.weight", [16]], ["blocks.1.2.bias", [16]], ["blocks.2.0.weight", [16, 8, 3, 3, 3]], ["blocks.2.0.bias", [8]], ["blocks.2.1.conv1.weight", [8, 8, 3, 3, 3]], ["blocks.2.1.conv1.bias", [8]], ["blocks.2.1.bn1.weight", [8]], ["blocks.2.1.bn1.bias", [8]], ["blocks.2.1.conv2.weight", [8, 8, 3, 3, 3]], ["blocks.2.1.conv2.bias", [8]], ["blocks.2.1.bn2.weight", [8]], ["blocks.2.1.bn2.bias", [8]], ["blocks.2.1.se.fc.0.weight", [0, 8]], ["blocks.2.1.se.fc.0.bias", [0]], ["blocks.2.1.se.fc.2.weight", [8, 0]], ["blocks.2.1.se.fc.2.bias", [8]], ["blocks.2.2.weight", [8]], ["blocks.2.2.bias", [8]], ["blocks.3.0.weight", [8, 4, 4, 4, 4]], ["blocks.3.0.bias", [4]], ["blocks.3.1.conv1.weight", [4, 4, 3, 3, 3]], ["blocks.3.1.conv1.bias", [4]], ["blocks.3.1.bn1.weight", [4]], ["blocks.3.1.bn1.bias", [4]], ["blocks.3.1.conv2.weight", [4, 4, 3, 3, 3]], ["blocks.3.1.conv2.bias", [4]], ["blocks.3.1.bn2.weight", [4]], ["blocks.3.1.bn2.bias", [4]], ["blocks.3.1.se.fc.0.weight", [0, 4]], ["blocks.3.1.se.fc.0.bias", [0]], ["blocks.3.1.se.fc.2.weight", [4, 0]], ["blocks.3.1.se.fc.2.bias", [4]], ["blocks.3.2.weight", [4]], ["blocks.3.2.bias", [4]], ["blocks.4.0.weight", [4, 1, 4, 4, 4]], ["blocks.4.0.bias", [1]], ["blocks.4.1.conv1.weight", [1, 1, 3, 3, 3]], ["blocks.4.1.conv1.bias", [1]], ["blocks.4.1.bn1.weight", [1]], ["blocks.4.1.bn1.bias", [1]], ["blocks.4.1.conv2.weight", [1, 1, 3, 3, 3]], ["blocks.4.1.conv2.bias", [1]], ["blocks.4.1.bn2.weight", [1]], ["blocks.4.1.bn2.bias", [1]], ["blocks.4.1.se.fc.0.weight", [0, 1]], ["blocks.4.1.se.fc.0.bias", [0]], ["blocks.4.1.se.fc.2.weight", [1, 0]], ["blocks.4.1.se.fc.2.bias", [1]], ["blocks.4.2.weight", [1]], ["blocks.4.2.bias", [1]], ["blocks.5.0.weight", [1, 1, 3, 3, 3]], ["blocks.5.0.bias", [1]], ["blocks.5.1.weight", [1]], ["blocks.5.1.bias", [1]]], "output_shape": [[8, 1, 256, 256, 256]], "num_parameters": [32, 32, 27648, 32, 32, 32, 27648, 32, 32, 32, 64, 2, 64, 32, 32, 32, 13824, 16, 6912, 16, 16, 16, 6912, 16, 16, 16, 16, 1, 16, 16, 16, 16, 3456, 8, 1728, 8, 8, 8, 1728, 8, 8, 8, 0, 0, 0, 8, 8, 8, 2048, 4, 432, 4, 4, 4, 432, 4, 4, 4, 0, 0, 0, 4, 4, 4, 256, 1, 27, 1, 1, 1, 27, 1, 1, 1, 0, 0, 0, 1, 1, 1, 27, 1, 1, 1]}], "edges": []}